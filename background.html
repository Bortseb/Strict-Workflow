<html>
  <script>
    // TODO: create PREFS module

    /*

      Constants

    */

    var DURATIONS = { // in seconds
      work: 25 * 60,
      break: 5 * 60
    }, BADGE_BACKGROUND_COLORS = {
      work: [192, 0, 0, 255],
      break: [0, 192, 0, 255]
    }, DOMAIN_BLACKLIST, RING = new Audio("http://www.matchusian.com/strict_pomodoro/ring.mp3"),
    shouldRing, ringLoaded = false;

    function setShouldRing(newShouldRing) {
      console.log('setting should ring: ', newShouldRing);
      shouldRing = localStorage['should_ring'] = newShouldRing;
      loadRingIfNecessary();
    }

    function loadRingIfNecessary() {
      console.log('is ring necessary?');
      if(shouldRing && !ringLoaded) {
        console.log('ring is necessary');
        RING.onload = function () { ringLoaded = true }
        RING.load();
      }
    }

    if(typeof localStorage['should_ring'] === 'undefined') {
      setShouldRing(true);
    } else {
      shouldRing = localStorage['should_ring'] == 'true';
      loadRingIfNecessary();
    }

    /* use this block for testing *
    DURATIONS = {
      work: 5,
      break: 5
    }
    /**/

    var ICONS = {
      ACTION: {
        CURRENT: {},
        PENDING: {}
      },
      FULL: {},
    }, iconTypeS = ['default', 'work', 'break'],
      iconType;
    for(var i in iconTypeS) {
      iconType = iconTypeS[i];
      ICONS.ACTION.CURRENT[iconType] = "icons/" + iconType + ".png";
      ICONS.ACTION.PENDING[iconType] = "icons/" + iconType + "_pending.png";
      ICONS.FULL[iconType] = "icons/" + iconType + "_full.png";
    }

    function setDomainBlacklist(newList) {
      DOMAIN_BLACKLIST = newList;
      localStorage['domain_blacklist'] = JSON.stringify(newList);
    }

    if(localStorage['domain_blacklist']) {
      DOMAIN_BLACKLIST = JSON.parse(localStorage['domain_blacklist']);
    } else {
      setDomainBlacklist([
        'facebook.com',
        'youtube.com',
        'twitter.com',
        'myspace.com',
        'livejournal.com',
        'digg.com',
        'reddit.com',
        'kongregate.com',
        'newgrounds.com',
        'addictinggames.com',
        'hulu.com'
      ]);
    }

    /*

      Models

    */

    function Pomodoro(options) {
      this.mostRecentMode = 'break';
      this.nextMode = 'work';
      this.running = false;

      this.onTimerEnd = function (timer) {
        this.running = false;
      }

      this.start = function () {
        var mostRecentMode = this.mostRecentMode, timerOptions = {};
        this.mostRecentMode = this.nextMode;
        this.nextMode = mostRecentMode;

        for(var key in options.timer) {
          timerOptions[key] = options.timer[key];
        }
        timerOptions.type = this.mostRecentMode;
        timerOptions.duration = options.durations[this.mostRecentMode];
        this.running = true;
        this.currentTimer = new Pomodoro.Timer(this, timerOptions);
        this.currentTimer.start();
      }
    }

    Pomodoro.Timer = function Timer(pomodoro, options) {
      var tickInterval, timer = this;
      this.pomodoro = pomodoro;
      this.timeRemaining = options.duration;
      this.type = options.type;

      this.start = function () {
        tickInterval = setInterval(tick, 1000);
        options.onStart(timer);
        options.onTick(timer);
      }

      this.timeRemainingString = function () {
        if(this.timeRemaining >= 60) {
          return Math.round(this.timeRemaining / 60) + "m";
        } else {
          return (this.timeRemaining % 60) + "s";
        }
      }

      function tick() {
        timer.timeRemaining--;
        options.onTick(timer);
        if(timer.timeRemaining <= 0) {
          clearInterval(tickInterval);
          pomodoro.onTimerEnd(timer);
          options.onEnd(timer);
        }
      }
    }

    /*

      Views

    */

    // The code gets really cluttered down here. Refactor would be in order,
    // but I'm busier with other projects >_<

    function locationsMatch(location, blacklistedPattern) {
      return domainsMatch(location.domain, blacklistedPattern.domain) &&
        pathsMatch(location.path, blacklistedPattern.path);
    }

    function parseLocation(location) {
      var components = location.split('/');
      return {domain: components[0], path: components[1]};
    }

    function pathsMatch(test, against) {
      /*
        index.php ~> [null]: pass
        index.php ~> index: pass
        index.php ~> index.php: pass
        index.php ~> index.phpa: fail
        /path/to/location ~> /path/to: pass
        /path/to ~> /path/to: pass
        /path/to/ ~> /path/to/location: fail
      */

      return !against || test.substr(0, against.length) == against;
    }

    function domainsMatch(test, against) {

      /*
        google.com ~> google.com: case 1, pass
        www.google.com ~> google.com: case 3, pass
        google.com ~> www.google.com: case 2, fail
        google.com ~> yahoo.com: case 3, fail
        yahoo.com ~> google.com: case 2, fail
        bit.ly ~> goo.gl: case 2, fail
        mail.com ~> gmail.com: case 2, fail
        gmail.com ~> mail.com: case 3, fail
      */

      // Case 1: if the two strings match, pass
      if(test === against) {
        return true;
      } else {
        var testFrom = test.length - against.length - 1;

        // Case 2: if the second string is longer than first, or they are the same
        // length and do not match (as indicated by case 1 failing), fail
        if(testFrom < 0) {
          return false;
        } else {
          // Case 3: if and only if the first string is longer than the second and
          // the first string ends with a period followed by the second string,
          // pass
          return test.substr(testFrom) === '.' + against;
        }
      }

    }

    function executeInTabIfBlacklisted(action, tab) {
      var file = "content_scripts/" + action + ".js", location;
      location = tab.url.split('://');
      location = parseLocation(location[1]);
      for(var k in DOMAIN_BLACKLIST) {
        blacklistedPattern = parseLocation(DOMAIN_BLACKLIST[k]);
        if(locationsMatch(location, blacklistedPattern)) {
          chrome.tabs.executeScript(tab.id, {file: file});
        }
      }
    }

    function executeInAllBlacklistedTabs(action) {
      var windows = chrome.windows.getAll({populate: true}, function (windows) {
        var tabs, tab, domain, blacklistedDomain;
        for(var i in windows) {
          tabs = windows[i].tabs;
          for(var j in tabs) {
            executeInTabIfBlacklisted(action, tabs[j]);
          }
        }
      });
    }

    var notification, mainPomodoro = new Pomodoro({
      durations: DURATIONS,
      timer: {
        onEnd: function (timer) {
          chrome.browserAction.setIcon({
            path: ICONS.ACTION.PENDING[timer.pomodoro.nextMode]
          });
          chrome.browserAction.setBadgeText({text: ''});
          notification = webkitNotifications.createNotification(
            ICONS.FULL[timer.type],
            "Time's up!",
            "Time for the " + timer.pomodoro.nextMode + " phase :)"
          );
          notification.show();
          if(shouldRing) RING.play();
        },
        onStart: function (timer) {
          chrome.browserAction.setIcon({
            path: ICONS.ACTION.CURRENT[timer.type]
          });
          chrome.browserAction.setBadgeBackgroundColor({
            color: BADGE_BACKGROUND_COLORS[timer.type]
          });
          if(timer.type == 'work') {
            executeInAllBlacklistedTabs('block');
          } else {
            executeInAllBlacklistedTabs('unblock');
          }
          if(notification) notification.cancel();
          var tabViews = chrome.extension.getViews({type: 'tab'}), tab;
          for(var i in tabViews) {
            tab = tabViews[i];
            if(typeof tab.startCallbacks !== 'undefined') {
              tab.startCallbacks[timer.type]();
            }
          }
        },
        onTick: function (timer) {
          chrome.browserAction.setBadgeText({text: timer.timeRemainingString()});
        }
      }
    });

    chrome.browserAction.onClicked.addListener(function (tab) {
      if(!mainPomodoro.running) mainPomodoro.start();
    });

    chrome.tabs.onUpdated.addListener(function (tabId, changeInfo, tab) {
      if(mainPomodoro.mostRecentMode == 'work') {
        executeInTabIfBlacklisted('block', tab);
      }
    });
  </script>
</html>

